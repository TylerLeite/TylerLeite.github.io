<!--
This is the source code, it's not too special. If you came here wondering why I
end my articles with a ìèà character, you're in luck.

It's the unicode character for the Egyptian hieroglyph for a milk jug (W20 jrtjt).
You may have noticed that the favicon for my website is also a milk jug, albeit a
more modern one. Basically what it comes down to is that my last name, Leite, is
Portuguese for milk.

If your browser can't render a ìèà, get a better one. Or a better computer. Or
update your fonts. Or just deal with it. I think those are the only options.


Banner image is edited from a photograph by Stephen W. Oachs http://www.stephenoachs.com/
-->

<html>
<head>
    <meta charset="utf-8">
    <meta lang="en-us">
    <meta name="viewport" content="width=device-width">

    <title>Articles</title>

    <link rel="icon" type="image/png" href="./graphics/favicon.png">

    <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="./css/normalize.css">

    <link rel="stylesheet" type="text/css" href="./css/style.css">
    <link rel="stylesheet" type="text/css" href="./css/articles.css">

    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();

      /* Usually anchors scroll you such that the top of the window lines up with
          the top of the element you're scrolling to. I'd prefer a bit more space
          at the top, so I have this listener
       */
      window.addEventListener(
        "hashchange",
        () => {
          window.scrollTo(window.scrollX, window.scrollY - 100);
        }
      );
    </script>
</head>
<body>
  <img class="banner" src="graphics/sf_skyline.png">
  <div class="page">
    <div class="">
      <p class="return"><a href="/home">&lt; Exit</a></p>

      <p class="title">Tyler's Articles</p>
      <div class="article">
        <p>
          Below is whatever I happen to write and feel like posting. Sometime's it's technical, sometimes it's not. Right now it's not much of anything, but I feel like it'll be a pretty mixed bag eventually.
        </p>

        <h2>Contents</h2>
        <ul class="contents">
          <li><a href="#animating-iron-pages">Animating &lt;iron-pages&gt; in Polymer 2.0 - July 11, 2017</a></li>
          <li><a href="#animating-iron-pages">Captain - August 15, 2017</a></li>
        </ul>
      </div>

      <hr>

      <!-- This is my article boilerplate. If I were running my own server, I would get articles from a database on my server. As it stands, I'm hosting this site on github pages, so my options are rather limited. In fact, the best I can really do (without a lot of extra work) is just paste all of these articles in here statically.
      <div class="titleWrapper">
        <a class="imgLink" href="#insert-title-here"><img class="link" src="./graphics/icons/link.png"></a>
        <p class="title" id="insert-title-here">INSERT TITLE HERE</p>
        <a href="/articles" class="linkBack">top ^</a>
      </div>

      <div class="article">
        <p>
          INSERT CONTENT HERE ìèà
        </p>
      </div>
      -->

      <div class="titleWrapper">
        <a class="imgLink" href="#captain"><img class="link" src="./graphics/icons/link.png"></a>
        <p class="title" id="captain">Captain</p>
        <a href="/articles" class="linkBack">top ^</a>
      </div>

      <div class="article">
        <p>
          Even he doesn‚Äôt know why he keeps staring out over the sea, it only hurts him. He‚Äôd never let it show, though. He puts on a good show for his men. The rocking of the ship rolls pens on his desk. It sets a dull metronome. He likes it. Quiet ticking sets a fragile backdrop. It suits his fancy. You would never think the captain a soft man, not unless you knew him. Not unless you could look in his eyes and truly see him. But there was no one around to see his face. Dirty, shaggy, wrinkled. In some ways, it‚Äôs exactly as you‚Äôd expect. He was sea-worn, heavily weathered, grimy. That‚Äôs how his men would pin him, at least. In need of repair. Maybe that‚Äôs better. More right, at least. If you knew to look, you‚Äôd see the streak. A slightly muddled blemish on his mask. Exactly one, from his right eye to the corner of his mouth. Maybe tonight it would grow. Each day it could. The ship rocked rather violently. Maybe something spilled in the kitchen. Captain thought he could hear the cook shouting something nasty. Nasty by any standards. Any other time, that might bring a smile to Captain‚Äôs face. He wasn‚Äôt in the mood though, and thought he might never be. For now it was just him and the sea. Him and the horizon. And her.
        </p>

        <p>
          It‚Äôs a struggle to knock. She knows what‚Äôs going on in there, and the last thing she‚Äôd want to do is make him scurry to hide his emotions. This is important though. Not for the crew, not for her, no. For him. Before she musters her courage, the door is opened. Captain looks her in the eye, and she looks back. His white hair, so clean and cared for. Most people would think it odd, such a weathered old sea-dog with hair that flows like a cotton sheet. Even more curious was its contrast with his beard. All gray and matted, more knotty than you‚Äôd think a lifetime of neglect could result in. More dirty than you‚Äôd think possible for a man who spends so much time away from dirt. It was strange, you could see the sharp outline of his jaw even through his thick coat, even through his years of age and stress. He was a beautiful man once. Some might say he still is, but in a different way. A deep man, with many lifetimes lived. His eyes did no work to betray his structure. Dark and violent as the storms that make him feel at home on the sea. Only a handful of people could see through it, perceive the man behind those eyes.
        </p>

        <p>
          His streak grew last tonight, he really did need this. She stepped forward, her face in his, almost touching. He could feel her trembling. Fear? In part at least. She was certainly nervous. He was too, but to be sure he would never show it. His eyes went straight to her hands. They were clasped around a roll of paper. Old and moth-bitten. Indistinct from any other forgotten clipping. But he was expecting this, had been for years. He knew exactly what was about to happen. It almost made him shudder. Perhaps if the door were still closed, he would have.
        </p>

        <p>
          ‚ÄúIt‚Äôs not too late.‚Äù He could hear the telltale vibrato of her stutter. This was bad, she never got this nervous. ‚ÄúYou and I can burn this, right here. Right now. It‚Äôll all be over. We can just forget about all this. Who‚Äôs going to find us out here?‚Äù He smiled. They both knew her words were empty. It was sweet of her to try, though.
        </p>

        <p>
          ‚ÄúOne day, Mal. One day, you‚Äôll grow old and jaded. Just like your old man. You‚Äôll know what this means to me. You‚Äôll know why I died for this.‚Äù She already knew. He already knew she knew. At this point, no words could have meaning. They were in each other‚Äôs minds. A perfect understanding. What else could you expect from a lifetime together? These days, she was the only one he could open up to. He liked it that way though, and deep down, so did she. Mal opened her mouth, almost involuntarily. What did she even want to say? What was she even able to say? Nothing. There was no turning back at this point. No, they were past that point for a long time now. Mal turned and left. The door closes behind her.
        </p>

        <p>
          Captain sat for a long time, gripping his roll of paper. His mind was made up, had been for years. He knew tonight was the night, but. But what? He was frightful. He often was. From day one, his gut turns at the slightest hint of danger. It kept him alert, alive. But today he no longer needed that. He calmed himself down, unraveled his scroll, and read. For the first time in his life, he refused to hold back his tears. As he read, the passages he finished were blotted away. The last memories he had of her, the only thing tying him to this world. Soon it would be gone forever. Soon. It was all over.
        </p>

        <p>
          Mal hardly slept that night. She put it off as long as she could, but midday came and there was no longer any time to wait. It had to be now. The walk to the Captain‚Äôs quarters is the longest it‚Äôs ever been. She raises her fist, stops herself. She opens the door. Empty. Silently, she weeps. Bites her tongue. This can‚Äôt happen anymore, she thinks. And she hides her tears. And she goes out to her men.
        </p>

        <p class="storyEnd">ìèà</p>
      </div>

      <div class="titleWrapper">
        <a class="imgLink" href="#animating-iron-pages"><img class="link" src="./graphics/icons/link.png"></a>
        <p class="title" id="animating-iron-pages">Animating &lt;iron-pages&gt; in Polymer 2.0</p>
        <a href="/articles" class="linkBack">top&nbsp;^</a>
      </div>

      <div class="article">
        <p>
          The <a target="_blank" href="https://www.webcomponents.org/element/PolymerElements/iron-pages">iron&#8209;pages</a> element is very useful. It lets you easily share data between several pages of an application and transition between them without much in the way of load time. The main downside is that you need to be careful about how you load in data (especially if you're hitting some API to get hundreds of megabytes of data from your server). But a that's not what I'm going to talk about right now. Right now, I will focus on another downside of <el>iron&#8209;pages</el>: they look kinda ugly. There isn't much in the way of flair. Back in the days of Polymer 1.0, we had this cool element <a target="_blank" href="https://www.webcomponents.org/element/PolymerElements/neon-animation/elements/neon-animated-pages">neon&#8209;animated&#8209;pages</a>, but the entire neon&#8209;animations package has since been <d>deprecated</d>. Webcomponents.org states "This Element is now deprecated. Please use the web animations api or CSS animations". Ok, simple enough right? Just take a look at the <el>iron&#8209;pages</el> source code, see that the transition between selected pages is just changing the display property of any unused page to 'none'. So all we need to do is add a css transition.
        </p>

<pre><code class="CSS">iron-pages > * {
  transition: display 2s;
}
</code></pre>

        <p>
          Would that it were so simple. You actually can't apply a transition to the display property. Which makes sense, since changing the display property can actually have tons of different effects, from size and position of the element itself to arrangement of its child elements. The web animations api doesn't seem too useful either. A css animation starts when the element is loaded and repeats from there (anywhere from zero to infinite times). So what gives? It seems like the fine folks developing PolymerElements left us stranded in the middle of the ocean with useless "advice" on how to swim. But maybe that advice isn't actually useless. Could it be that they're pulling a Miyagi, pointing us in the right direction without actually giving us the answer? Yes, of course. I'm not like that though, I'll just give you the answer.
        </p>

<pre><code class="html">&lt;!-- In your src element's body --&gt;
&lt;style&gt;
  iron-pages > .iron-selected {
    transition: opacity 0.5s;
  }
&lt;/style&gt;

&lt;iron-pages
  id="pages"
  selected="{{selected}}"
&gt;
  &lt;div&gt;My Page 1&lt;/div&gt;
  &lt;div&gt;My Page 2&lt;/div&gt;
  &lt;div&gt;My Page 3&lt;/div&gt;
&lt;/iron-pages&gt;
</code></pre>

<pre><code class="JavaScript">// In your src element's properties
selected: {
  type: Number,
  notify: true,
  value: 0,
  observer: '_newPageSelected',
},


// A member function of your src element
_newPageSelected (newVal, oldVal) {
  let pages = this.$.pages.children;

  pages[newVal].style.opacity = 0;
  setTimeout(
    ((node) => {
      node.style.opacity = 1;
    }).bind(this, pages[newVal]), 0);
}
</code></pre>

        <p>
          What does this even mean? Well let me define a few things real quick. First off, when I say your "src element", I mean the element that contains your <el>iron&#8209;pages</el>. Therefore, your src element's body is anything between the two <el>template</el> tags that should make up the first and only child of your <el>dom&#8209;module</el> element. The src element's properties would be the return value of its <c>properties()</c> function, and the member functions are just the element's... member functions. If you're not sure about what that means, you need to brush up on your OOP skills.
        </p>

        <p>
          Ok, so here's what's going on in the code above. First, we are creating our <el>iron&#8209;pages</el> element and creating a two-way data bind to one of our src element's properties. In this case, we're just calling it <i>selected</i>. We then create an observer for this property, so we can run some code whenever it changes. This is useful to us since <el>iron&#8209;pages</el> will never change the page without also changing its 'selected' property, and therefore our src element's 'selected' property. In this observer, we first set the current page's opacity to 0. This is our workaround. Since we can't create a transition for the display property, we just need to make sure that our page's opacity is changing right along with it. And opacity <i>is</i> something we can create a transition for. But we're not done yet. We still need to set the opacity back to 1, or else the whole page would just be invisible and useless. We do this with <c>window.setTimeout</c> so that we can run it asynchronously. Otherwise, some voodoo would go on and our rendering agent wouldn't realize that the opacity changed at all (so no transition).
        </p>

        <p>If you're still confused about how this all fits together, check out <a target="_blank" href="/examples/animating-iron-pages/transition">this example</a> of a full src element (opens in a new tab). Once you understand how that works, you can get more fancy with your transitions. No need to stop at fading in and fading out, you can adjust scale, position, color scheme... the possibilites are (actually) endless. Just set an initial value in the observer, a final value in the asynchronous function, and a transition in the CSS.</p>

        <p>This method is nice and simple, but there is a bit of a flaw. If the user switches between pages while a transition is going on, you'll get some funky behavior. You can see what I mean by editing my example and setting the transition duration to 5s, then clicking between tabs very quickly. You queue up all those transitions and it breaks them until the time has passed. There are two ways around this. One is to have a timer that starts when the transition starts and ends when the transition ends. In your <c>select()</c> function, just check if that timer is going and refuse to switch while it is.</p>

<pre><code class="JavaScript"> // This is defined outside the src-element definition
function select (n) {
  let src = document.querySelector('my-src');
  if (src.transitionReady) {
    let pages = src.$.pages;
    pages.select(n);
  }
}

// This is a member function of your src-element
_newPageSelected (newVal, oldVal) {
  let pages = this.$.pages.children;

  pages[newVal].style.opacity = 0;
  setTimeout(
    ((node) => {
      node.style.opacity = 1;
    }).bind(this, pages[newVal]), 0);

  this.set('transitionReady', false); // Make sure you add this to properties as well
  setTimeout(
    (() => {
      this.set('transitionReady', true);
    }).bind(this), 5000); // Change this to be the same as your transition time in milliseconds
}
</code></pre>

        <p>
          The obvious problem here is that you're taking away responsiveness from the user. If your transition is five seconds long, your user is going to get annoyed at having to wait for that transition every time they misclick a link. If you lower the timeout, it defeats the whole purpose as you still get the transition interruption bug. So how can we be more flexible and allow for the best possible user experience? Let's check the docs. <i>"This Element is now deprecated. Please use the web animations api or </i><b>CSS animations</b><i>"</i>.
        </p>

        <p>
          <i>"But Tyler, you said that animations weren't useful because they just looped when the element loaded or something!"</i> Actually, that was a bit misleading. An element's css animation actually restarts whenever its animation property changes. Equally as important, you can interrupt a css animation at any time by simply deleting its animation property (or removing the class that added it), meaning we won't have the same issue of jittery transitions when the user switches pages too quickly.
        </p>

        <p>
          Because running and stopping an animation is as easy as adding or removing a class, we can actually use almost the same code as for the transition method. The only difference is that rather than changing a style property, you change a class. That and you need to define a css animation (obviously). Actually, all told the animation code is a bit simpler since you don't need to worry about any <c>setTimeout()</c> shenanigans. Here's the code:
        </p>

<pre><code class="html">&lt;!-- In your src element's body --&gt;
&lt;style&gt;
  /* Define the animation here. You can do pretty much anything you want. */
  @keyframes slide {
    from { left: -70%; }
    to { left: 0; }
  }

  /* Adding this class starts the animation, removing it cuts it short */
  .animated {
    animation-duration: 1s;
    animation-name: slide;
  }
&lt;/style&gt;
</code></pre>

<pre><code class="JavaScript">_newPageSelected (newVal, oldVal) {
  let pages = this.$.pages.children;

  // Run the animation on the newly selected page
  if (!pages[newVal].className.includes('animated')) {
    pages[newVal].className += ' animated';
  }

  if (typeof oldVal !== 'undefined') {
    // Stop the animation of hidden pages
    pages[oldVal].className = pages[oldVal].className.split(' animated').join('');
  }
}
</code></pre>

        <p>
          Again, if you're still having trouble understanding, check out this <a target="_blank" href="/examples/animating-iron-pages/animation">more complete example</a>
        </p>

        <p>
          So what's better, <an>animations</an> or <trn>transitions</trn>? Well, animations are less of a headache and offer better control over keyframes. It's also cleaner to animate a lot of properties than to transition a lot of them because of the little hack we need to do with <c>setTimeout()</c> when dealing with transitions. However, from a more philosophical standpoint, transitions are what you're <i>supposed</i> to use. The point of a transition is to transition between states, whereas the point of an animation is to animate an element (tough to grasp, I know). So maybe it feels a bit hacky, or that you're shoehorning in animations where you don't need them. After all, I believe that the animation method is actually a bit more resource-intensive than the transition method. Don't quote me on that though, I haven't actually run any benchmarks and don't want to. At the end of the day though, I recommend just sticking with what you're comfortable with. In my personal opinion, using animations is cleaner and easier. But neither is objectively right or wrong. ìèà
        </p>

      </div>
    </div>
  </div>
</body>
</html>
